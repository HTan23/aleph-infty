<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Sparkling</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
            body {
                margin: 0;
                background-color: #000;
                color: #fff;
                font-family: Monospace;
                font-size: 13px;
                line-height: 24px;
                overscroll-behavior: none;
            }

            a {
                color: #ff0;
                text-decoration: none;
            }

            a:hover {
                text-decoration: underline;
            }

            button {
                cursor: pointer;
                text-transform: uppercase;
            }

            canvas {
                display: block;
            }

            #info {
                position: absolute;
                top: 0px;
                width: 100%;
                padding: 10px;
                box-sizing: border-box;
                text-align: center;
                -moz-user-select: none;
                -webkit-user-select: none;
                -ms-user-select: none;
                user-select: none;
                pointer-events: none;
                z-index: 1; /* TODO Solve this in HTML */
            }

            a, button, input, select {
                pointer-events: auto;
            }

            .dg.ac {
                -moz-user-select: none;
                -webkit-user-select: none;
                -ms-user-select: none;
                user-select: none;
                z-index: 2 !important; /* TODO Solve this in HTML */
            }

            #overlay {
                position: absolute;
                z-index: 2;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
                background: rgba(0,0,0,0.7);
            }

                #overlay button {
                    background: #ffffff;
                    border: 0;
                    color: #000000;
                    padding: 16px 20px;
                    text-transform: uppercase;
                    cursor: pointer;
                }

            #notSupported {
                width: 50%;
                margin: auto;
                background-color: #f00;
                margin-top: 20px;
                padding: 10px;
            }
        </style>
	</head>

	<body>
		<div id="info">Heart Shape Sparkling Particles</div>
		<div id="container"></div>

		<script type="x-shader/x-vertex" id="vertexshader">

            attribute float visible;
			attribute float size;
            attribute vec3 customColor;
            
			uniform float sizeRatio;
			uniform float canvasSize;

            varying vec3 vColor;
            varying float pVisible;

			void main() {

                vColor = customColor;
                
				pVisible = visible;

				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );

				gl_PointSize = size * ( sizeRatio * canvasSize / 100.0 / -mvPosition.z );

				gl_Position = projectionMatrix * mvPosition;

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshader">
            
			uniform vec3 color;
			uniform sampler2D pointTexture;
            
			varying vec3 vColor;
            varying float pVisible;

			void main() {

                if ( pVisible < 0.5 ) discard;

				gl_FragColor = vec4( color * vColor, 1.0 );
				gl_FragColor = gl_FragColor * texture2D( pointTexture, gl_PointCoord );

			}

		</script>

        <script src="js/three.min.js"></script>
        <script src="js/OrbitControls.js"></script>

        <!-- <script src="js/BloomPass.js"></script> -->
        <script src="js/EffectComposer.js"></script>
        <script src="js/RenderPass.js"></script>
        <script src="js/LuminosityHighPassShader.js"></script>
        <script src="js/CopyShader.js"></script>
        <script src="js/ShaderPass.js"></script>
        <script src="js/UnrealBloomPass.js"></script>

        <script src="js/stats.min.js"></script>
        <script src="js/dat.gui.min.js"></script>
		<script>

			let renderer, scene, camera, stats, controls, composer, gui;

            let sphere;
            
            let bloomThresholdController;

			const WIDTH = window.innerWidth;
            const HEIGHT = window.innerHeight;
            
            const MAX_COUNT = 1e4;
            const INIT_COUNT = 2000;

            const params = {
				exposure: 0.1,
				bloomStrength: 3.0,
				bloomThreshold: 1.0,
                bloomRadius: 0.5,
                
                animated: true,
                lastTimeStamp: 0,
                timeStamp: 0,
			};
            const data = {
                pointCount: INIT_COUNT,
                pointSize: 20.0,
            };

			init();
			animate();

			function init() {

                camera = new THREE.PerspectiveCamera( 40, WIDTH / HEIGHT, 1, 10000 );
				camera.position.y = 50;
                camera.position.z = 200;
                camera.lookAt(0, 0, 0);


				scene = new THREE.Scene();

				const amount = MAX_COUNT;
				const radius = 5;

				const visibles = new Float32Array( amount );
				const positions = new Float32Array( amount * 3 );
				const colors = new Float32Array( amount * 3 );
				const sizes = new Float32Array( amount );

				const vertex = new THREE.Vector3();
				const color = new THREE.Color( 0xffffff );

				for ( let i = 0; i < amount;  ) {

                    const x = ( Math.random() * 2 - 1 ) * radius;
                    const y = ( Math.random() * 2 - 1 ) * radius;
                    const z = ( Math.random() * 2 - 1 ) * radius;
                    
                    const lhs = Math.pow(x * x + y * y + 4 * z * z - 1, 3);
                    const rhs = x * x * y * y * y + z * z * y * y * y * 0.1;
                    
                    if ( lhs > rhs ) continue;
                    
					vertex.x = x;
					vertex.y = y;
                    vertex.z = z;
					vertex.toArray( positions, i * 3 );

					color.setHSL( 0.0 + 0.3 * y / radius, 0.9, 0.5 + 0.3 * Math.random() );

					color.toArray( colors, i * 3 );

                    sizes[ i ] = 20;

                    visibles[ i ] = i < INIT_COUNT ? 1.0 : 0.0;
                    
                    i++;
				}

				const geometry = new THREE.BufferGeometry();
				geometry.setAttribute( 'visible', new THREE.BufferAttribute( visibles, 1 ) );
				geometry.setAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
				geometry.setAttribute( 'customColor', new THREE.BufferAttribute( colors, 3 ) );
				geometry.setAttribute( 'size', new THREE.BufferAttribute( sizes, 1 ) );

				//

                const texture = new THREE.Texture();
                const image = document.createElement("img");
                image.src = "data:image/png;base64,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";
                texture.image = image;
                // export const RGBAFormat = 1023;
                texture.format = 1023;
                texture.needsUpdate = true;

				const material = new THREE.ShaderMaterial( {

					uniforms: {
						color: { value: new THREE.Color( 0xffffff ) },
						pointTexture: { value: texture },
						sizeRatio: { value: data.pointSize },
						canvasSize: { value: HEIGHT }
					},
					vertexShader: document.getElementById( 'vertexshader' ).textContent,
					fragmentShader: document.getElementById( 'fragmentshader' ).textContent,

					blending: THREE.AdditiveBlending,
					depthTest: false,
                    transparent: true,
                    
                    uniformsNeedUpdate: true

				} );

				//

                sphere = new THREE.Points( geometry, material );
                sphere.position.set( 0, -20, 0 );
                sphere.rotation.set( 0, 90, 0 );
                sphere.scale.set( 50, 50, 50 );
				scene.add( sphere );

				//

				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( WIDTH, HEIGHT );
                renderer.toneMapping = THREE.ReinhardToneMapping;
                renderer.toneMappingExposure = Math.pow(params.exposure, 4.0);

				document.getElementById( 'container' ).appendChild( renderer.domElement );

				//

				window.addEventListener( 'resize', onWindowResize, false );

                controls = new THREE.OrbitControls( camera, renderer.domElement );
                controls.dampingFactor = 0.03;
                controls.enableDamping = true;
                controls.enablePan = false;
                controls.minPolarAngle = 0.1 * Math.PI;
                controls.maxPolarAngle = 0.9 * Math.PI;

                const renderScene = new THREE.RenderPass( scene, camera );

				const bloomPass = new THREE.UnrealBloomPass( new THREE.Vector2( WIDTH, HEIGHT ), 1.5, 0.4, 0.85 );
				bloomPass.threshold = params.bloomThreshold;
				bloomPass.strength = params.bloomStrength;
				bloomPass.radius = params.bloomRadius;

				composer = new THREE.EffectComposer( renderer );
				composer.addPass( renderScene );
				composer.addPass( bloomPass );

                stats = new Stats();
                document.body.appendChild( stats.dom );
                
                gui = new dat.GUI();

                gui.add( data, 'pointCount', 100.0, MAX_COUNT).onChange( function() { setVisibility( data.pointCount ) } );
                gui.add( data, 'pointSize', 1.0, 100.0).onChange( function() { sphere.material.uniforms.sizeRatio.value = data.pointSize; } );

                const folder = gui.addFolder("Blooming");
                folder.open();
                folder.add(params, 'exposure', 0.1, 2).onChange(function (value) {
                    renderer.toneMappingExposure = Math.pow(value, 4.0);
                });

                bloomThresholdController = folder.add( params, 'bloomThreshold', 0.0, 1.0 ).step( 0.01 ).onChange( function (value) {
                    bloomPass.threshold = Number(value);
                });

                folder.add( params, 'bloomStrength', 0.0, 3.0 ).onChange( function (value) {
                    bloomPass.strength = Number(value);
                });

                folder.add( params, 'bloomRadius', 0.0, 1.0 ).step( 0.01 ).onChange( function (value) {
                    bloomPass.radius = Number(value);
                });
                
                folder.add( params, 'animated' ).onChange( function (value) {
                    if ( value ) params.lastTimeStamp = 0;
                });
			}

			function onWindowResize() {

                sphere.material.uniforms.canvasSize.value = window.innerHeight;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

                renderer.setSize( window.innerWidth, window.innerHeight );
                
				composer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				requestAnimationFrame( animate );

                controls.update();

				render();

            }
            
            function setVisibility( count ) {

				const geometry = sphere.geometry;

                const attributes = geometry.attributes;

				for ( let i = 0; i < attributes.visible.array.length; i ++ ) {

					attributes.visible.array[ i ] = i < count ? 1.0 : 0.0;

				}

                attributes.visible.needsUpdate = true;
                
            }

            function timingFunction( x ) {
                return x === 0
                ? 0
                : x === 1
                ? 1
                : x < 0.5 ? Math.pow(2, 20 * x - 10) / 2
                : (2 - Math.pow(2, -20 * x + 10)) / 2;
            }

			function render() {

				const time = Date.now() * 0.005;

				sphere.rotation.y = 0.05 * time;

				const geometry = sphere.geometry;
				const attributes = geometry.attributes;

				for ( let i = 0; i < attributes.size.array.length; i ++ ) {

					attributes.size.array[ i ] = 28 + 22 * Math.sin( 0.1 * i + time );

                }
                
                if ( params.animated ) {

                    const pTime = time * 0.02;

                    if ( params.lastTimeStamp == 0) {

                        params.lastTimeStamp = pTime;

                    } else {
                        
                        params.timeStamp += ( pTime - params.lastTimeStamp );
                        
                        params.timeStamp = params.timeStamp % 2;
                        
                        bloomThresholdController.setValue(
                            0.1 + 0.7 * timingFunction( params.timeStamp > 1 ? params.timeStamp - 1 : 1 - params.timeStamp)
                            );
                            
                        params.lastTimeStamp = pTime;

                    }

                }

				attributes.size.needsUpdate = true;

                // renderer.render( scene, camera );

				composer.render();
                
                stats.update();
			}

		</script>

</body>

</html>